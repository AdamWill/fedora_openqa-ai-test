#!/usr/bin/python3

# Copyright Red Hat
#
# This script is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Adam Williamson <awilliam@redhat.com>

"""Script to sanity check the openQA -> wiki results mapping in
conf_test_suites.py.
"""

import glob
import json
import os
import subprocess
import sys
import tempfile

from wikitcms import wiki
from wikitcms.exceptions import NotFoundError, TooManyError

# add src subdirectory directory to module import path
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'src'))

from fedora_openqa.conf_test_suites import (TESTCASES, TESTSUITES)
import fedora_openqa.report as report

# wikitcms site object
SITE = wiki.Wiki()

# cache of ValidationPage objects
PAGES = {}

## UTILITY CLASSES AND FUNCTIONS

class FakeClient(object):
    """A fake OpenQA_Client which just returns our fake job dicts. We
    need this to handle the 'testsuites' condition in TESTSUITES
    entries, which allows a test case to be considered passed only if
    the parent test suite *and* a list of other test suites passed;
    get_passed_testcases handles that by querying openQA for other
    jobs for the same build and checking their result, but obviously
    for our fake jobs, we need a fake openQA 'server'..."""
    def __init__(self, jobs):
        self.jobs = jobs

    def openqa_request(self, method, endpoint, params=None):
        """This is nowhere near a full implementation, it's highly
        tuned to what get_passed_testcases needs.
        """
        gotjobs = self.jobs
        if 'machine' in params:
            gotjobs = [job for job in gotjobs if job['settings']['MACHINE'] == params['machine']]
        if 'flavor' in params:
            gotjobs = [job for job in gotjobs if job['settings']['FLAVOR'] == params['flavor']]
        return {'jobs': gotjobs}


def read_templates(distripath):
    """Read in the openQA templates from distripath."""
    # Locate FIF template loader, check it exists
    loader = os.path.join(distripath, 'fifloader.py')
    if not os.path.isfile(loader):
        sys.exit("Could not find template loader at {0}".format(loader))
    # Locate expected templates file
    tmppath = os.path.join(distripath, 'templates.fif.json')

    # Write upstream format templates to a temp file
    with tempfile.NamedTemporaryFile() as tempfh:
        cmd = [loader, '-w', '--filename', tempfh.name, tmppath]
        ret = subprocess.run(cmd)
        ret.check_returncode()
        # Read the JSON and return it
        return json.load(tempfh)

def get_page(testtype):
    """Get the page if we didn't yet, cache it, and return from cache."""
    ttype = testtype
    if testtype == "General":
        # only IoT events have a General page
        ttype = "General_IoT"
    if not testtype in PAGES:
        PAGES[testtype] = SITE.pages[f"Template:{ttype}_test_matrix"]
    return PAGES[testtype]

def cases_from_suite(suite):
    """Get test case names from a TESTSUITE."""
    tscases = TESTSUITES[suite]
    casenames = []
    try:
        # complex (dict) case
        casenames.extend(tscases.keys())
    except AttributeError:
        # simple list case
        casenames = tscases
    return casenames

def fake_jobs(templates, modules):
    """Create a set of fake passed openQA jobs from JobTemplates and
    the module names in TestSuites (as found by conds_modules_match).
    """
    fakejobs = []
    for jobtemp in templates['JobTemplates']:
        # we only run x86_64 and aarch64 in prod ATM, and we only care
        # about result reporting for prod, so ignore other arches for now
        if jobtemp['arch'] not in ('x86_64', 'aarch64'):
            continue
        # ignore templates whose version is not "*" - these are only for
        # old releases, so won't be release validation tests, so won't
        # be reported to wiki
        if jobtemp['version'] != "*":
            continue
        subv = jobtemp['flavor'].split('-')[0]
        try:
            imagetype = jobtemp['flavor'].split('-')[1].replace('_', '-')
        except IndexError:
            # universal
            imagetype = "universal"
        job = {
            'id': 1,
            'settings': {
                'ARCH': jobtemp['arch'],
                'FLAVOR': jobtemp['flavor'],
                'SUBVARIANT': subv,
                'IMAGETYPE': imagetype,
                'TEST': jobtemp['test_suite_name'],
                'MACHINE': jobtemp['machine_name'],
                # we don't need the BUILD value; we're just going to use
                # the current validation pages
                'BUILD': 'Fedora-FAKE',
            },
            'result': 'passed',
            # we use both settings['TEST'] and test, we probably shouldn't...
            'test': jobtemp['test_suite_name'],
            # we just pretend every single job had all the modules that
            # are used for individual module->result mapping; this is
            # harmless for the cases where it's a lie, as get_passed_testcases
            # will entirely ignore it except for the TESTSUITES that specify
            # the modules.
            'modules': [{'name': module, 'result': 'passed'} for module in modules]
        }
        # need this to trigger the special handling in get_passed_testcases
        if jobtemp["flavor"].lower().startswith("iot"):
            job["settings"]["BUILD"] = "Fedora-IoT-FAKE"
        # find the desktop by finding the relevant Product and getting it
        # from its settings
        for setting in [prod for prod in templates['Products'] if
                        prod['flavor'] == jobtemp['flavor']][0]['settings']:
            if setting['key'] == 'DESKTOP':
                job['settings']['DESKTOP'] = setting['value']
        # Special exception: we must not include the
        # workstation_core_applications module in the KDE apps_startstop
        # test as this will cause a spurious 'No ResultRow found' - in
        # reality that module is not scheduled for the KDE test
        if jobtemp['test_suite_name'] == 'apps_startstop':
            if job['settings']['DESKTOP'] == 'kde':
                job['modules'] = [item for item in job['modules']
                                  if item['name'] != 'workstation_core_applications']
        fakejobs.append(job)
    return fakejobs

## CHECK FUNCTIONS

def cases_suites_match():
    """Check all case names referred in TESTSUITES are actually in
    TESTCASES and vice versa.
    """
    failed = 0
    # Check all case names referred in TESTSUITES are in TESTCASES
    # also store all case names in TESTSUITES for reverse check
    alltscases = set()
    for tsname in TESTSUITES.keys():
        casenames = cases_from_suite(tsname)
        alltscases.update(casenames)
        for casename in casenames:
            if casename not in TESTCASES.keys():
                print("Test case {0} listed in test suite {1} is not in TESTCASES!".format(
                    casename, tsname))
                failed = 1

    # check all case names in TESTCASES are used in TESTSUITES
    for casename in TESTCASES.keys():
        if casename not in alltscases:
            print("Test case {0} from TESTCASES is never used in TESTSUITES!".format(casename))
            failed = 1

    return failed

def templates_suites_match(templates):
    """Check all test suites from templates are in TESTSUITES, and
    vice versa, except for ones we know are OK (e.g. support_server).
    """
    failed = 0
    tempsuites = [suite['name'] for suite in templates['TestSuites']]
    onlytemp = set(tempsuites) - set(TESTSUITES.keys())
    for suite in onlytemp:
        failed = 1
        print("Test suite {0} is in templates, but not in TESTSUITES!".format(suite))

    onlysuites = set(TESTSUITES.keys()) - set(tempsuites)
    for suite in onlysuites:
        failed = 1
        print("Test suite {0} is in TESTSUITES, but not in templates!".format(suite))

    return failed

def conds_testsuites_match():
    """For TESTSUITES entries which use the 'testsuites' condition,
    check all listed suite names are in TESTSUITES, and warn if there
    is no equivalent reverse mapping (as usually we'd expect one).
    """
    failed = 0
    for (tsname, cases) in TESTSUITES.items():
        try:
            for (tcname, conds) in cases.items():
                for othertsname in conds.get('testsuites', []):
                    othersuite = TESTSUITES.get(othertsname)
                    if not othersuite:
                        print("Test suite {0} listed as a cond in case {1} in suite {2} "
                              "not found in TESTSUITES!".format(othertsname, tcname, tsname))
                        failed = 1
                    othercase = othersuite.get(tcname, {})
                    if tsname not in othercase.get('testsuites', []):
                        print("Warning: suite {0} case {1} has suite {2} as cond, but suite {2} "
                              "case {1} does not have suite {0} as cond".format(
                                  tsname, tcname, othertsname))
        except AttributeError:
            pass
    return failed

def conds_modules_match(distripath):
    """Check all modules listed in TESTSUITES entries which use the
    'modules' condition actually exist in the distri, and return the
    module names for the wiki check to use.
    """
    failed = 0
    distrimods = glob.glob(os.path.join(distripath, 'tests', '*.pm'))
    distrimods = [os.path.basename(mod) for mod in distrimods]
    distrimods = [mod.split('.pm')[0] for mod in distrimods]
    modules = set()
    for (suite, cases) in TESTSUITES.items():
        try:
            for (case, conds) in cases.items():
                for module in conds.get('modules', []):
                    modules.add(module)
                    if module not in distrimods:
                        print("Module {0} listed in case {1} in suite {2} not found in "
                              "distri!".format(module, case, suite))
                        failed = 1
                modules.update(conds.get('modules', []))
        except AttributeError:
            pass
    return (failed, modules)

def check_wiki_mapping(templates, modules):
    """Produce wikitcms ResTups for a set of fake passed jobs produced
    by fake_jobs, then check we got a ResTup for every test case in
    TESTCASES, and we can find a ResultRow and env for every generated
    ResTup in the current validation event wiki pages.
    """
    failed = 0
    fakejobs = fake_jobs(templates, modules)
    # Now we have a bunch of fake 'passed jobs', we can ask report.py to
    # give us ResTups for them
    # Create an instance of our fake 'openQA client' with the fake jobs
    fakeclient = FakeClient(fakejobs)
    # Call get_passed_testcases with the fake jobs and client
    restups = report.get_passed_testcases(fakejobs, fakeclient)

    # Catch if there are any test cases we don't produce a single
    # result for, even with a full set of 'passed jobs'
    restupcases = set([restup.testcase for restup in restups])
    for case in set(TESTCASES.keys()) - restupcases:
        print("No wiki result generated for test case {0}!".format(case))

    for restup in restups:
        # this will get us the current validation page for the testtype
        page = get_page(restup.testtype)
        # now we use find_resultrow - which is what report_validation_results
        # uses - with the appropriate values from the ResTup
        try:
            row = page.find_resultrow(restup.testcase, restup.section, restup.testname, restup.env)
            # if we got a ResultRow, check the environment from the ResTup
            # is actually in the ResultRow's result columns. We just copy
            # the code for the match right out of page.add_results()...
            cands = [cand for cand in row.results.keys() if restup.env.lower() in cand.lower()]
            # we should have *exactly one* cand
            if len(cands) == 0:
                if restup.env  == "CoreOS":
                    # we don't track coreos or ELN (BaseOS) results in wiki
                    pass
                else:
                    print("Env {0} not found in ResultRow: case {1}, name {2}, section {3}, "
                          "page {4}!".format(restup.env, row.testcase, row.name,
                                             row.section, restup.testtype))
                    failed = 1
            if len(cands) > 1:
                print("Too many matches found for env {0} in ResultRow {1}!".format(
                    restup.env, row.testcase))
                failed = 1
        except NotFoundError:
            if restup.env == 'Everything' and restup.testcase == 'QA:Testcase_base_startup':
                # this is fine. I am OK with the events that are occurring
                pass
            elif any(skp in restup.env or skp in restup.testname for skp in ("BaseOS", "CoreOS")):
                # we don't track coreos or ELN (BaseOS) results in wiki
                pass
            else:
                print("No ResultRow found for {0}".format(restup))
                failed = 1
        except TooManyError:
            print("Too many ResultRows found for {0}".format(restup))
            failed = 1

    return failed

## MAIN FUNCTIONS

def main():
    """Main function. Just reads the templates and runs each test."""
    if not len(sys.argv) == 2:
        sys.exit("Usage: {0} distripath".format(sys.argv[0]))
    distripath = sys.argv[1]
    templates = read_templates(distripath)
    # Ongoing 'did we fail yet?' indicator
    failed = 0
    # Run the checks
    if cases_suites_match():
        failed = 1
    if templates_suites_match(templates):
        failed = 1
    if conds_testsuites_match():
        failed = 1
    (ret, modules) = conds_modules_match(distripath)
    if ret:
        failed = 1
    if check_wiki_mapping(templates, modules):
        failed = 1
    # Exit appropriately
    sys.exit(failed)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        sys.stderr.write("Interrupted, exiting...\n")
        sys.exit(1)
